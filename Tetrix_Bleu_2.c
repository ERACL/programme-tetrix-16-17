#pragma config(Hubs,  S1, HTMotor,  HTServo,  none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     touchSensor,    sensorTouch)
#pragma config(Sensor, S3,     SonarArriere,   sensorSONAR)
#pragma config(Sensor, S4,     SonarAvant,     sensorSONAR)
#pragma config(Motor,  motorA,          pince,         tmotorNXT, PIDControl, reversed, encoder)
#pragma config(Motor,  motorB,          verrin,        tmotorNXT, openLoop, reversed, encoder)
#pragma config(Motor,  motorC,          funny,         tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     motorA,        tmotorMatrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     motorB,        tmotorMatrix, openLoop, reversed)
#pragma config(Servo,  srvo_S1_C2_1,    servo1,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "redButton.c"
#include "mouvement_droit_new.c"
#include "funny_action.c"
//#include "point_turn.c"

/*
Tous les temps sont exprimes en ms.
Toutes les distances sont exprimees en mm.
Convention moteurs :
 - motorA = moteur droit
 - motorB = moteur gauche
*/


/*
A faire pour la suite : ne jamais modifier les valeurs de nMotorEncoder[], sauf a l'initialisation.
*/


/*
--------------------------------------------------------------------------------------------------
---------------------------- PROGRAMME DU ROBOT TETRIX COTE BLEU ---------------------------------
------ PROGRAMME 2 : IL PREND LES CYLINDRES DE LA TOUR ET LES PLACE DANS LA ZONE DE DEPART -------
----- PUIS IL PREND UN CYLINDRE DE LA TOUR ET LE PLACE DANS UN EMPLACEMENT PREVU  CET EFFET ------
------------------------------------ SUR LE COTE DU TERRAIN --------------------------------------
--------------------------------------------------------------------------------------------------
*/



void turnLeftDeg_safe(float angle)
{
	float angle_safe = 0;
	char done = 0;
	float sum = 0.0;
	while(done == 0 && angle - sum > 0)
	{
		turnLeftDeg(angle-sum, &angle_safe, &done);
		sum += angle_safe;
		if(done == 0)
		{
				nxtDisplayTextLine(3, "angle_sum = %f", sum);
				nxtDisplayTextLine(4, "done = %d", done);
			wait1Msec(150);
		}
	}
}

void turnRightDeg_safe(float angle)
{
	float angle_safe = 0;
	char done = 0;
	float sum = 0.0;
	while(done == 0 && angle - sum > 0)
	{
		turnRightDeg(angle-sum, &angle_safe, &done);
		sum += angle_safe;
		if(done == 0)
			wait1Msec(150);
	}
}


task tourne_pince_droitT()
{
	motor[pince]=40;
	wait1Msec(6000);
	motor[pince]=0;
}

void place_pince()
{
	while(abs(nMotorEncoder[pince]) > 3)
	{
		motor[pince]=nMotorEncoder[pince]*(-1.3);
		wait1Msec(10);
	}
	motor[pince]=0;
}


task rentre_verrinT()
{
	motor[verrin]=100;
	wait1Msec(5000);
	motor[verrin]=0;
}

void rentre_verrin()
{
	motor[verrin]=100;
	wait1Msec(5000);
	motor[verrin]=0;
}

task sort_verrinT()
{
	motor[verrin]=-100;
	wait1Msec(5000);
	motor[verrin]=0;
}

void sort_verrin()
{
	motor[verrin]=-100;
	wait1Msec(5000);
	motor[verrin]=0;
}


/*
void prend_cylindre()
{
	wait1Msec(100);
	avance_nulle(1300);
	wait1Msec(200);

	// On a attrape un cylindre

	recule_nulle(100);
	//wait1Msec(200);
	//recule_nulle(100);
	wait1Msec(200);
	turnLeftDeg(170, 20);
	wait1Msec(100);
}

void depose_cylindre(int trigo)
{
	if(trigo == 1)
		startTask(tourne_pince_gaucheT);
	else
		startTask(tourne_pince_droitT);
	wait1Msec(1000);
//	avance_nulle(70);
	sort_verrin();
	startTask(rentre_verrinT);
	wait1Msec(200);

//	recule_nulle(70);
	wait1Msec(100);

}

void se_place_depose(int distance)
{
	wait1Msec(100);
	avance_nulle(distance);
	wait1Msec(200);
	turnRightDeg(160, 20);
	wait1Msec(100);
}

void se_place_cylindre(int distance)
{
	recule_nulle(50);
	wait1Msec(100);
	turnRightDeg(175, 20);
	wait1Msec(100);
	avance_nulle(distance-45);
	wait1Msec(100);
	turnLeftDeg(190, 20);
	wait1Msec(100);
}
*/

task main()
{
	nMotorEncoder[motorA]=0;
	nMotorEncoder[motorB]=0;
	nMotorEncoder[pince]=0;

	//rayon = 46.3;
	rayon = 25.1;
	matrix_or_tetrix=2;
	//offset_motor=16; // Pour passer la bascule avec une matrix.
	offset_motor=15;
	// Gestion des obstacle, savoir si on les prend en compte ou non. 1 pour les prendre en compte, 0 sinon.
	obstacle = 1;
	entraxe = 190;
	start=0;

	//startTask(position);
	startTask(rentre_verrinT);

	startTask(redButton);
	start=0;

	while(start == 0)
		wait1Msec(10);

	startTask(funnyAction);


	saturation_dpuiss_avant = 100;
	saturation_dpuiss_arriere = 100;

	float dist;
	float angle;
	char done;
	char obs;

// Passage de la bascule

	// Attendre que le petit robot parte.
	wait1Msec(11000);

	obstacle = 0;
	recule_nulle(100, &dist, &done, &obs, 700);
	wait1Msec(100);

	obstacle = 1;

	avance_nulle_anyway(680, &dist, &done, &obs);
	wait1Msec(100);


	obstacle = 0;
	// On se recalibre sur la bascule pour savoir ou on est.
	wait1Msec(400);
	recule_nulle(90, &dist, &done, &obs, 1500);
	obstacle = 1;
	wait1Msec(100);
	avance_nulle_anyway(170, &dist, &done, &obs, 3000);
	wait1Msec(100);
	turnRightDeg_safe(170);
	wait1Msec(100);
	recule_nulle(300, &dist, &done, &obs, 1000);
	obstacle = 1;
	// On est cale contre le mur
	// Prise du cylindre, on parcourt un rectangle

	wait1Msec(300);
	avance_nulle_anyway(300, &dist, &done, &obs);
	nxtDisplayTextLine(2, "dist : %f", dist);
	nxtDisplayTextLine(3, "done : %d", done);
	nxtDisplayTextLine(4, "obs : %d", obs);

	wait1Msec(100);
	turnLeftDeg_safe(180);
	wait1Msec(100);
	avance_nulle_anyway(130, &dist, &done, &obs);
	wait1Msec(100);
	turnLeftDeg_safe(180);
	obstacle = 0;
	wait1Msec(100);
	// Prise du cylindre
	avance_nulle(250, &dist, &done, &obs, 1300, 27);
	obstacle = 0;
	// Cylindre pris.
	wait1Msec(200);
	obstacle = 1;

	// Parcours securise.
	dist = 0;
	float sum_d = 0;
	done = 0;
	while(done == 0 && 200-sum_d>0)
	{
		recule_nulle_anyway(200, &dist, &done, &obs, 0, 13);
		if(done == 0)
			wait1Msec(100);
	}


	wait1Msec(100);
	obstacle = 0;
	// Cylindre sorti de la fusee.

	startTask(sort_verrinT);
	wait1Msec(10);

	// On tourne de maniere securisee
	turnLeftDeg_safe(95);
	//nxtDisplayTextLine(3, "angle = %f", angle);
	//nxtDisplayTextLine(4, "done = %d", done);

	wait1Msec(100);
	avance_nulle(140, &dist, &done, &obs);
	// Depose le cylindre dans la base.
	// On attend que le verrin sorte.
	wait1Msec(1000);
	recule_nulle(40, &dist, &done, &obs);

	wait1Msec(3000);
	stopTask(sort_verrinT);
	wait1Msec(10);
	rentre_verrin();
	obstacle = 1;
	recule_nulle_anyway(105, &dist, &done, &obs);
	obstacle = 0;
	wait1Msec(300);
	turnRightDeg_safe(95);
	wait1Msec(100);


	// De nouveau mis en place pour prendres des cylindres dans la fusee.
		obstacle = 0;
		avance_nulle(350, &dist, &done, &obs, 1000, 25);
		// Cylindre pris.
		wait1Msec(200);
		obstacle = 1;
		//Cylindre 2 pris dans la fusee.
		recule_nulle(150, &dist, &done, &obs, 2500, 13);

		wait1Msec(100);
	// Demi-tour
	turnRightDeg_safe(175);
	wait1Msec(100);
	turnRightDeg_safe(160);
	wait1Msec(100);
	avance_nulle_anyway(530, &dist, &done, &obs);
	wait1Msec(200);
	turnRightDeg_safe(170);
	wait1Msec(100);

	// On atteint la base
	avance_nulle_anyway(770, &dist, &done, &obs);
	wait1Msec(100);
	startTask(tourne_pince_droitT);
	wait1Msec(100);
	avance_nulle_anyway(70, &dist, &done, &obs);

	startTask(sort_verrinT);
	wait1Msec(5000);

	recule_nulle_anyway(100, &dist, &done, &obs);

	wait1Msec(90000);
}
